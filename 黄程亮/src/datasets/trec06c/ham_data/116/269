Received: from postoffice10.mail.cornell.edu (postoffice10.mail.cornell.edu [132.236.56.14])
	by sundial.cs.cornell.edu (8.11.7-20031020/8.11.7/M-3.22) with ESMTP id k27G0gt16879
	for <egs+summary@cs.cornell.edu>; Tue, 7 Mar 2006 11:00:42 -0500 (EST)
Received: from orpheus3.dataserver.cornell.edu (orpheus3.dataserver.cornell.edu [128.253.161.167])
	by postoffice10.mail.cornell.edu (8.12.10/8.12.6) with ESMTP id k27G0f7r007290;
	Tue, 7 Mar 2006 11:00:41 -0500 (EST)
Message-ID: <2094271417.1141747240665.JavaMail.webber@orpheus3.dataserver.cornell.edu>
Date: Tue, 7 Mar 2006 11:00:40 -0500 (EST)
From: Gopal Parameswaran <gp72@cornell.edu>
To: egs+summary@cs.cornell.edu
Subject: PAPER 12
Cc: gp72@cornell.edu
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
X-Mailer: uPortal WEB email client 3.0
Content-Transfer-Encoding: 8bit
X-MIME-Autoconverted: from quoted-printable to 8bit by sundial.cs.cornell.edu id k27G0gt16879

PAST:
This paper presents a method for storage management and caching of files using Pastry for client request routing and adding and deleting nodes. Its primary functionality is to ensure that files are replicated k times in the network with a focus on caching of popular files. Since it relies on the underlying Pastry, the queries are of the order of log N. The authors claim that their system provides high availability, scalability and security though most of it is based on Pastry’s implementation. PAST also uses hashes of files for identification and retrieval.
 Past supports three primary operations of adding a new file called Insert and a Lookup functionality and a Reclaim function that actually frees up the resources allocated to the stored file. When an insert request in made to insert a file into the network the SHA-1 hash of the file’s name with the client’s public key and a random salt is taken and it is redirected to the nearest node as per Pastry and then from that node forwarded to the next nearest node till k nodes have a copy of the file. Past also specifies a client storage requirement and removes the size of the storage used for all k copies from the client’s quota. The client receives an acknowledgement from all the k nodes that have the copies called the store receipt. For a lookup the client sends the SHA1 hash made for the file and Pastry does the lookup and returns a copy of the file with a high probability of returning a copy that is nearest to the client due to the locality properties of the Pastry routing schema. The deleting of a file or reclaiming the resources is the same process as adding but instead frees up the resources allocated to the copy of the file and returns back a reclaim receipt. 
	Past introduces the concept of smartcards for security of peer to peer networks to identify users. This identification of the users makes the concept of a paid peer to peer service also more realizable especially for the area of storage where the clients are being charged for the service of k fault tolerance storage. Past does storage distribution among its nodes based a storage capacity that is mentioned when a node joins a network and used as an admission criteria.	However Past does not focus on the an important issue in file storage and retrieval with regards to improving the latency of the system especially since for file systems file storage and retrieval would be a more common task and low latency requirements could be critical. This paper does not distinguish between performance tuning in terms of optimizing storage and allocating storage capacity based on connection speeds. This plays an important role since a bad client might offer a large storage capacity over a slow network and thus slow down all request that come to it.

CFS
In this paper the authors present the concept of a peer-to-peer storage network that uses Chord as its underlying peer-to-peer network and tries to handle robustness and load balancing and effective distribution of files.  CFS is composed of two primary layers, viz. the Dhash layer and the underlying Chord. The Dhash layer performs block fetches and distribution of the file into the network by using the second layer of Chord as a distributed lookup system. It differs from the Past implementation above with regards to the distribution of the files in the network. Past stores the contents of a file at once location and hence for large files it cannot store it in the network on the associated nodes though the nodes together collectively can store it. Instead it offloads it to servers that have sufficient free space. CFS on the other hand breaks up the file into blocks and stores the data as blocks and thus is more granular in its approach. Thus the files are no longer restricted in terms of available storage capacity at a particular node but a collective capacity of the network. Also since it is broken down into smaller packets the reliability of CFS would be higher than Past since if two copies of the same file is corrupted or the nodes that contain them are down in different places Past would not be able to take either of the two files and they both becomes useless. In the case of CFS since only the individual packets are lost or corrupted the packets that correspond to the faulty section of the file are discarded and the rest can be used. CFS also differs from Past in not supporting a delete operation but instead relying on a periodic update by the client to maintain the data. However this approach also subjects the system to the condition that if the client wants to reuse storage space allocated to him he has to wait till the timeout period for the update request. Also this particular scheme also has another serious drawback in that if a client goes down due to some network issues and cannot come back up in time

