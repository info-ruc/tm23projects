Received: from dhcp98-182.cs.cornell.edu (dhcp98-182.cs.cornell.edu [128.84.98.182])
	by sundial.cs.cornell.edu (8.11.7/8.11.7/M-3.12a) with ESMTP id h8277dj15958
	for <egs+615@cs.cornell.edu>; Tue, 2 Sep 2003 03:07:39 -0400 (EDT)
Subject: 615 PAPER 1
From: Krzysztof Ostrowski <krzys@cs.cornell.edu>
Reply-To: krzys@cs.cornell.edu
To: egs+615@cs.cornell.edu
Content-Type: text/plain
Organization: Cornell University
Message-Id: <1062486460.4803.24.camel@dhcp98-182.cs.cornell.edu>
Mime-Version: 1.0
X-Mailer: Ximian Evolution 1.2.2 (1.2.2-5) 
Date: 02 Sep 2003 03:07:40 -0400
Content-Transfer-Encoding: 7bit


The Destination-Sequenced Distance-Vector (DSDV) routing algorithm is
one of many algorithms based on the distributed version of Bellman-Ford
shortest-path algorithm (DBF). Like in the RIP internet routing
protocol, and unlike in "link-state" methods, each node maintains
information only about the distance (number of "hops") and "next hop" on
a way to every known destination and information about current network
topology and current routes is distributed over the set of communicating
nodes. Unlike in methods based on "source-routing", route for each
individual data packet is being dynamically constructed while the packet
is in transit. Formation of loops, a common issue with distance-vector
algorithms, is avoided by introducing "route sequence numbers",
generated by destination nodes when broadcasting route tables. Sequence
numbers are associated with routes leading to a given destination by
nodes receiving such broadcasted route tables, and such routes are
further propagated to the rest of the ad-hoc network in the usual way. A
restriction is placed on updates to routing tables that routes with
higher sequence numbers are always preferred over routes with lower
numbers. This ensures that stale information will never override fresh
routing data. It can be proven that this restriction, combined with the
usual DBF assumption that of every two equally fresh routes the one with
smaller number of hops is preferred, makes it impossible even for
short-term loops to emerge. This method of avoiding loops is not only
much simpler, and therefore more likely to be applied than any earlier
methods based on some sort of internodal coordination, but also likely
to prove faster and less expensive, and therefore more suitable to apply
in environments where changes in topology are very frequent. At the same
time, the total size of routing tables is linear with the number of
nodes, like in RIP and unlike in other routing algorithms known at that
time. 

Another major contribution of DSDV is introducing dynamically computed
"route settling time", representing an estimate of time required for new
routing information arriving at a given node to stabilize. Re-broadcasts
of updated routes are delayed, thus helping to avoid flooding of the
network and rapid fluctuations in route tables. Other novel ideas
include maintaining separate routing tables for data packet forwarding
and for route re-broadcasting (so as to avoid situations where new
routing information arriving to a given node from different directions
triggers a burst of new route propagations). Broken links are handled in
the usual way by propagating "negative" information. The way sequence
numbers are chosen ensures that broken link data always overrides stale
route data while always being overridden by newly discovered routes. 

The Dynamic Source Routing (DSR) algorithm is similar to link-state
methods in that nodes attempt to acquire full information about the
current state of network connectivity. Routes can then be calculated
locally (using a traditional shortest path algorithm) and therefore are
loop-free. Like in the source routing technique known from wired
networks, packets have routes pre-determined at the time they are sent
by the source and cannot change while packets are in transit. Unlike in
DSDV, or in other distance-vector or link-state methods, however,
routing information is not gathered and propagated periodically in a
distributed fashion, but rather obtained on-demand, when it is needed by
a node willing to send a data packet, which helps to reduce control
overhead (a) in periods when changes in topology are less frequent, and
(b) in situations where some of nodes do not need to communicate and
therefore do not need routing information. Obtaining routing information
is performed via a "route discovery" algorithm, essentially flooding the
newtork with a request (in a way somewhat analogous to breadth-first
search, with a list of visited nodes included in the request so as to
avoid duplicates and loops) that is ultimately picked up by destination
and results in a response sent back to the sender. When destination does
not have the route to the sender, it performs its own route discovery,
piggybacking response on its own route request (so that the source will
ultimately receive the response, update its routing information and
reply to the destination using its newly acquired routing data). All
routes are cached, and hence an intermediate node may reply to route
discovery request without the need for contacting the destination (as
long as its route, combined with route from source stored in the
request, does not form a loop). 

An interesting property of this algorithm is the ability to effectively
use the "promiscuous mode" of some wireless networks interfaces. Since
routing requests contain partial routing information, other nodes
overhearing them may use it to update their own routing tables.
Broken-link discovery in DSR (based on passive, hop-by-hop or
timeout-driven, explicitly requested acknowledgement) is efficiently
handled by propagation of error packets along the affected cached
routes. A major issue with DSR arises when network becomes partitioned,
resulting in repeated route requests. While DSR is superior to DSDV in
periods of stability in that it does not involve any control overhead,
in the situation described above it will keep consuming bandwidth while
traditional DBF-based methods will quickly remove navailable nodes from
their routing tables. As a solution, a back-off mechanism is used.
Another issue with DSR is its space complexity, naturally limiting its
scalability, and this includes cached routes, lists of of recently
forwarded requests etc. as well as visited nodes in requests.

The Ad-hoc On-Demand Distance Vector (AODV) algorithm combines ideas
from DSDV and DSR. Like in DSR, routes are acquired on demand via
flooding the network with route requests that eventually reach the
destination, acquired information is cached, therefore there are no
periodic network-wide broadcasts and nodes that do not need to send,
receive or relay messages need not participate in the algorithm and the
control overhead can be kept fairly low. Unlike in DSR, however, and
somewhat like in distance-vector algorithms, no node maintains complete
routing information, route table entries for paths from sources to
destinations are dynamically established and kept in intermediate nodes
in a distributed way (on a hop-by-hop basis). While intermediate nodes
forward a route request sent by source, they build a distributed tree
pointing backwards to the source. A response is traveling back to the
source along a path in the tree, intermediate nodes forwarding it setup
entries in their routing tables to form a distributed routing path
pointing forward from the source to the destination and any nodes that
are not lying on the path use timeout to remove the unnecessary data
structures. In order to keep latency in reasonable limits, intermediate
nodes are allowed to reply if they already contain routing information
for a given destination. Since this might introduce loops, the idea of
sequence numbers was borrowed from DSDV to guarantee that routes are
loop-free. Every request or response sent gets a new sequence number and
those numbers are recorded on path in the routing tables in all the
intermediate nodes. Source node also includes last known destination
sequence number in its routing request and intermediate nodes are not
allowed to reply to this request if destination sequence numbers in
their tables are smaller that the number requested by source. An
argument similar to the one used in proving loop-free property of DSDV
(using the fact that sequence numbers on a path to destination are
non-decreasing) can then be applied to prove that no loops can emerge. 

Unlike DSDV and DSR, AODV has relatively small memory requirements since
only information about actively used routes is stored. A route
maintenance algorithm including locally broadcast hello messages (to
monitor local connectivity), expiration timers for cached routes and
route requests, measuring times since last packets were received from
all neighboring nodes are used to keep track of active nodes, hops and
routes. Stale routes are quickly deleted. Information about broken links
is propagated along the active routes, routes are truncated and source
nodes resend route request to re-establish connectivity. Also, any
changes in routes to destinations resulting e.g. from node movements are
propagated directly to sources along active paths. Simulations show that
AODV can scale to hundreds of nodes while keeping goodput ratio of up to
80-90%, with only 10-30% bandwidth overhead and latencies within
200-500ms.


