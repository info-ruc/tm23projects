Received: from smtp101.plus.mail.re2.yahoo.com (smtp101.plus.mail.re2.yahoo.com [206.190.53.26])
	by cs.utexas.edu (8.13.5/8.13.5) with SMTP id k1O0evM1022435
	for <cs395t-mark@cs.utexas.edu>; Thu, 23 Feb 2006 18:40:58 -0600 (CST)
Received: (qmail 73831 invoked from network); 24 Feb 2006 00:40:51 -0000
Received: from unknown (HELO ?127.0.0.1?) (jeffreyrdiamond@128.83.122.73 with plain)
  by smtp101.plus.mail.re2.yahoo.com with SMTP; 24 Feb 2006 00:40:51 -0000
Message-ID: <43FE55C0.70709@cs.utexas.edu>
Date: Thu, 23 Feb 2006 18:39:28 -0600
From: Jeff Diamond <jdiamond@cs.utexas.edu>
User-Agent: Mozilla Thunderbird 1.0 (Windows/20041206)
X-Accept-Language: en-us, en
MIME-Version: 1.0
To: cs395t-mark@cs.utexas.edu
Subject: TCC brings up a very interesting point...
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

When it comes to high performance, parallel code, maybe we *shouldn't* 
want non-expert programmers to be able to write it.  If we make it seem 
simple when it's really not, then everyone will try to write parallel 
programs.  Currently, if someone writes a poorly optimized program, my 
OS will multitask it amoung the rest of my computer and only that 
program will run slowly.  But if I launch even a tiny app (say a clock) 
that a naive programmer wrote with TCC, now my entire computer can be 
brought down by cache overflow.   (You definitely don't want a heart 
monitor implemented in TCC.)

Seems like this is moving in the wrong direction along so many axis...
I think an important rule of abstraction is "don't hide something that 
matters".





