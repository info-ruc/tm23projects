Received: from authusersmtp.mail.cornell.edu (granite1.mail.cornell.edu [128.253.83.141])
	by sundial.cs.cornell.edu (8.11.7-20031020/8.11.7/M-3.25) with ESMTP id k3IFdc217711
	for <egs+summary@cs.cornell.edu>; Tue, 18 Apr 2006 11:39:38 -0400 (EDT)
Received: from KEVSTOY (cpe-69-207-37-246.twcny.res.rr.com [69.207.37.246])
	(authenticated bits=0)
	by authusersmtp.mail.cornell.edu (8.13.1/8.12.10) with ESMTP id k3IFdbLt011761
	(version=TLSv1/SSLv3 cipher=RC4-MD5 bits=128 verify=NOT)
	for <egs+summary@cs.cornell.edu>; Tue, 18 Apr 2006 11:39:37 -0400 (EDT)
Message-ID: <000601c662fe$50c08f90$f625cf45@KEVSTOY>
Reply-To: "Kevin" <yobz@cornell.edu>
From: "Kevin" <km266@cornell.edu>
To: <egs+summary@cs.cornell.edu>
Subject: PAPER 22
Date: Tue, 18 Apr 2006 11:39:43 -0400
MIME-Version: 1.0
X-Security: message sanitized on sundial.cs.cornell.edu
	See http://www.impsec.org/email-tools/sanitizer-intro.html
	for details. $Revision: 1.148 $Date: 2004-12-19 11:59:17-08 
X-Security: The postmaster has not enabled quarantine of poisoned messages.
Content-Type: multipart/alternative;
	boundary="----=_NextPart_000_0003_01C662DC.C937C3C0"
X-Priority: 3
X-MSMail-Priority: Normal
X-Mailer: Microsoft Outlook Express 6.00.2900.2869
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2869

This is a multi-part message in MIME format.

------=_NextPart_000_0003_01C662DC.C937C3C0
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Implementing Declarative Overlays introduces P2, a system that allows =
the user to concisely specify an overlay network.  A language, OverLog, =
is introduced which uses rules and relations to construct an overlay.  =
This system allows tables (which they argue are necessary because many =
current overlays use tables to store neighbor state and other such =
information), streams, and uses a high level language to specify a =
system.  Overlog is a query language which the authors claim to derived =
from Datalog, which in turn is derived from Prolog.  The authors argue =
that their system is a distributed version of previous systems.  The =
authors constantly claim that they wrote Chord in 47 lines of code.  =
While I have no doubt that they did, those 47 lines are, in my opinion, =
confusing and intertwined.  They depend on each other so much that =
debugging in this language seems like a nightmarish task.

Macedon uses finite state machines which compile down into a lower level =
language (C/C++), allowing an advanced programmer access to any code =
they felt they could not specify clearly enough at a high level.  The =
high level language they use is far less confusing than Overlog and =
reminds me more of typical C-style languages.  The language allows you =
to specify finite state machines quickly and logically.  The main =
drawback to these two systems is the amount of pre-planning and thought =
that goes into every line.  While CHORD can be expressed in 47 lines or =
several hundred lines, these lines each took significantly more time to =
write than a single line in the Java implementation of Chord.  If the =
Java implementation is 10x as long as the Macedon implementation but it =
took 10x less time to write each line, the gain is minimal.  Worse yet, =
the implementation Macedon gives is not even a full Chord =
implementation.

--Kevin
------=_NextPart_000_0003_01C662DC.C937C3C0
Content-Type: text/html; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<DEFANGED_META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<DEFANGED_META content=3D"MSHTML 6.00.5296.0" name=3DGENERATOR>
 <!-- <DEFANGED_STYLE> --> </DEFANGED_STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>Implementing Declarative Overlays =
introduces=20
P2,&nbsp;a system that allows the user to concisely specify an overlay=20
network.&nbsp; A language, OverLog, is introduced which uses rules and =
relations=20
to construct an overlay.&nbsp; This system allows&nbsp;tables (which =
they argue=20
are necessary because many current overlays use tables to store neighbor =
state=20
and other such information), streams, and uses a high level =
language&nbsp;to=20
specify a system.&nbsp; Overlog is a query language which the authors =
claim to=20
derived from Datalog, which in turn is derived from Prolog.&nbsp; The =
authors=20
argue that their system is a distributed version of previous =
systems.&nbsp; The=20
authors constantly claim that they wrote Chord in 47 lines of =
code.&nbsp; While=20
I have no doubt that they did, those 47 lines are, in my opinion, =
confusing and=20
intertwined.&nbsp; They depend on each other so much that debugging in =
this=20
language seems like a nightmarish task.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Macedon uses finite state machines =
which compile=20
down into a lower level language (C/C++), allowing an advanced =
programmer access=20
to any code they felt they could not specify clearly enough at a high=20
level.&nbsp; The high level language they use is far less confusing than =
Overlog=20
and reminds me more of typical C-style languages.&nbsp; The language =
allows you=20
to specify finite state machines quickly and logically.&nbsp; The main =
drawback=20
to these two systems is the amount of pre-planning and thought that goes =
into=20
every line.&nbsp; While CHORD can be expressed in 47 lines or several =
hundred=20
lines, these lines each took significantly more time to write than a =
single line=20
in the Java implementation of Chord.&nbsp; If the Java implementation is =
10x as=20
long as the Macedon implementation but it took 10x less time to write =
each line,=20
the gain is minimal.&nbsp; Worse yet, the implementation Macedon gives =
is not=20
even a full Chord implementation.</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>--Kevin</FONT></DIV></BODY></HTML>

------=_NextPart_000_0003_01C662DC.C937C3C0--

